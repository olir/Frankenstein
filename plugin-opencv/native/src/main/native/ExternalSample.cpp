#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <cmath>

#include "nativeCode.h" // generated by javah via maven-native-plugin

#include "JwMat.h"
#include "jni_helper.h"
#include "cv_helper.h"

using namespace std;

JNIEXPORT void JNICALL Java_de_serviceflow_frankenstein_plugin_opencv_jni_ExternalSample_init
  (JNIEnv* env, jobject obj)
{
  JwMat* mat = JwMat::matptr;
  if (mat == NULL) {
	 JwMat::matptr = new JwMat(env);
  }
}

void CircleRowT1(int x,  int y, int radius, long rowptr, int xmid, int channels, int frameId);

// draw row of circle at "ymid + y" from -x to +x at xmid offset
void CircleRowT1(int x,  int y, int radius, long rowptr, int xmid, int channels, int frameId) {

  int keyHue = ((frameId - 1) % 256);

  jbyte * data = (jbyte *)rowptr;
  int i = (xmid-x) * channels;
  for (int xx=-x; xx<=x; xx++, i+= channels) {
    // 
    
    int h = atan2(xx, y) * 128 / 3.141592653589793238462643383279 + 128;
    int v = 255 - 255 * (xx * xx + y * y) / (radius * radius);
    int s = 2 * (CLAMP(v, 0, 255) - 128);
    if (s<0)
       s = 255 + s;
    else {
      s = 255 - s;
      v = 255 - v;
    }

    int range = 3;
    int hlower = keyHue - range;
    int hupper = keyHue + range;

    // if ( (h > hlower && h < hupper) || (hlower<0 && h>255+hlower) || (hupper>255 && h<hupper-255))
    {
      int distance = keyHue - h;
      if (distance<0)
        distance = -distance;
      if (distance>127)
        distance  = 255 - distance;
      
      v = v * range * 255 / (range + distance) / 255;
    }
    //else
    //{
//      v = 0;
    //}
    
    data[i+0] = CLAMP(h, 0, 255);
    data[i+1] = CLAMP(s, 0, 255);
    data[i+2] = CLAMP(v, 0, 255);
  }
  
}

void CircleRow(int x,  int y, int radius, long rowptr, int xmid, int channels, int frameId);

// draw row of circle at "ymid + y" from -x to +x at xmid offset
void CircleRow(int x,  int y, int radius, long rowptr, int xmid, int channels, int frameId) {

  jbyte * data = (jbyte *)rowptr;
  int i = (xmid-x) * channels;
  for (int xx=-x; xx<=x; xx++, i+= channels) {
    // 
    
    int h = atan2(xx, y) * 128 / 3.141592653589793238462643383279 + 128;
    int v = 255 - 255 * (xx * xx + y * y) / (radius * radius);
    int s = 2 * (CLAMP(v, 0, 255) - 128);
    if (s<0)
       s = 255 + s;
    else
      s = 255 - s;
    data[i+0] = CLAMP(h, 0, 255);
    data[i+1] = CLAMP(s, 0, 255);
    data[i+2] = CLAMP(v, 0, 255);
  }
  
}

JNIEXPORT void JNICALL Java_de_serviceflow_frankenstein_plugin_opencv_jni_ExternalSample_process
  (JNIEnv* env, jobject obj,
   jobject matobj, jint frameId, jobject context)
{
  JwMat* mat = JwMat::matptr;
  int cols = mat->cols(env, matobj);
  int rows = mat->rows(env, matobj);
//  cout << "rows=" << rows << ", cols=" << cols << endl;

  int channels = mat->channels(env, matobj);
  if (channels<3) {
	  J_THROW("java/lang/Error", "Expecting HSV Mat. channels < 3: "+mat->channels(env, matobj));
      return;
  }

  long dataAddr = mat->dataAddr(env, matobj);
  long step1 = mat->step1(env, matobj);

  // Black background
  long rowPtr = dataAddr;
  for(int y = 0; y < rows; y++)
  {
    jbyte * data = (jbyte *)rowPtr;
    for (int x = 0; x < cols; x++)
    {
      int i = x * channels;
      data[i+2] = 0; // value -> black
    }
    rowPtr += step1;
  }
  
  int radius = cols > rows ? (rows>>1) - 1 : (cols>>1) - 1;
  
  // midpoint circle
  int x = 0;
  int y = radius;
  long rowPtr1 = dataAddr + step1 * (rows>>1);
  long rowPtr2 = rowPtr1;
  long rowPtr3 = rowPtr1;
  long rowPtr4 = rowPtr1;
  rowPtr1 -= step1 * y;
  rowPtr2 += step1 * y;
  int d = 1 - radius;
  CircleRowT1(x, y, radius, rowPtr1, cols>>1, channels, frameId);
  CircleRowT1(x, -y, radius, rowPtr2, cols>>1, channels, frameId);
  CircleRowT1(y, x, radius, rowPtr3, cols>>1, channels, frameId);
  CircleRowT1(y, -x, radius, rowPtr4, cols>>1, channels, frameId);
  while (y > x) {
    if (d<0) {
      d+=2*x+3;
      x++;
      rowPtr3 -= step1;
      rowPtr4 += step1;
    }
    else {
      d+=2*(x-y)+5;
      x++;
      rowPtr3 -= step1;
      rowPtr4 += step1;
      y--;
      rowPtr1 += step1;
      rowPtr2 -= step1;
    }
    CircleRowT1(x, y, radius, rowPtr1, cols>>1, channels, frameId);
    CircleRowT1(x, -y, radius, rowPtr2, cols>>1, channels, frameId);
    CircleRowT1(y, x, radius, rowPtr3, cols>>1, channels, frameId);
    CircleRowT1(y, -x, radius, rowPtr4, cols>>1, channels, frameId);
  }
}


