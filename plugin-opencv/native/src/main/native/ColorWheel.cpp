#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <cmath>

#include "nativeCode.h" // generated by javah via maven-native-plugin

#include "JwMat.h"
#include "jni_helper.h"
#include "cv_helper.h"

using namespace std;

JNIEXPORT void JNICALL Java_de_serviceflow_frankenstein_plugin_opencv_jni_ColorWheel_init
  (JNIEnv* env, jobject obj)
{
  JwMat* mat = JwMat::matptr;
  if (mat == NULL) {
	 JwMat::matptr = new JwMat(env);
  }
}

void CircleRow(int x,  int y, int radius, long rowptr, int xmid, int channels, int frameId, bool positive);

// draw row of circle at "ymid + y" from -x to +x at xmid offset
void CircleRow(int x,  int y, int radius, long rowptr, int xmid, int channels, int frameId, bool positive) {

  jbyte * data = (jbyte *)rowptr;
  int i = (xmid-x) * channels;
  int y2= y*y;

  for (int xx=-x; xx<=x; xx++, i+= channels) {
    // 
    
    int h = atan2(xx, y) * 128 / 3.141592653589793238462643383279 + 128;
    int vbase = (511 * sqrt(xx * xx + y2)) / radius;
    vbase = CLAMP(vbase, 0, 511);
    int v = vbase;
    if (positive) {
    	v = 511 - v;
    	vbase = 511 - v;
    }
    v = CLAMP(v, 0, 255);
    int s = 2 * ((vbase>>1) - 128);
//    if ((vbase%64)==0)
//    {
//    	s = 0;
//    	v = 0;
//    }
//    else
    if (s<0)
    {
       s = 255 + s;
    }
    else if (s>=0)
    {
      s = 255 - s;
    }
    data[i+0] = CLAMP(h, 0, 255);
    data[i+1] = CLAMP(s, 0, 255);
    data[i+2] = CLAMP(v, 0, 255);
  }
  
}

JNIEXPORT void JNICALL Java_de_serviceflow_frankenstein_plugin_opencv_jni_ColorWheel_process
  (JNIEnv* env, jobject obj,
   jobject matobj, jint frameId, jobject context, jboolean positive)
{
  JwMat* mat = JwMat::matptr;
  int cols = mat->cols(env, matobj);
  int rows = mat->rows(env, matobj);
//  cout << "rows=" << rows << ", cols=" << cols << endl;

  int channels = mat->channels(env, matobj);
  if (channels<3) {
	  J_THROW("java/lang/Error", "Expecting HSV Mat. channels < 3: "+mat->channels(env, matobj));
      return;
  }

  long dataAddr = mat->dataAddr(env, matobj);
  long step1 = mat->step1(env, matobj);

  // Black background
  long rowPtr = dataAddr;
  for(int y = 0; y < rows; y++)
  {
    jbyte * data = (jbyte *)rowPtr;
    for (int x = 0; x < cols; x++)
    {
      int i = x * channels;
      data[i+2] = 0; // value -> black
    }
    rowPtr += step1;
  }
  
  int radius = cols > rows ? (rows>>1) - 1 : (cols>>1) - 1;
  
  // midpoint circle
  int x = 0;
  int y = radius;
  long rowPtr1 = dataAddr + step1 * (rows>>1);
  long rowPtr2 = rowPtr1;
  long rowPtr3 = rowPtr1;
  long rowPtr4 = rowPtr1;
  rowPtr1 -= step1 * y;
  rowPtr2 += step1 * y;
  int d = 1 - radius;
  CircleRow(x, y, radius, rowPtr1, cols>>1, channels, frameId, positive);
  CircleRow(x, -y, radius, rowPtr2, cols>>1, channels, frameId, positive);
  CircleRow(y, x, radius, rowPtr3, cols>>1, channels, frameId, positive);
  CircleRow(y, -x, radius, rowPtr4, cols>>1, channels, frameId, positive);
  while (y > x) {
    if (d<0) {
      d+=2*x+3;
      x++;
      rowPtr3 -= step1;
      rowPtr4 += step1;
    }
    else {
      d+=2*(x-y)+5;
      x++;
      rowPtr3 -= step1;
      rowPtr4 += step1;
      y--;
      rowPtr1 += step1;
      rowPtr2 -= step1;
    }
    CircleRow(x, y, radius, rowPtr1, cols>>1, channels, frameId, positive);
    CircleRow(x, -y, radius, rowPtr2, cols>>1, channels, frameId, positive);
    CircleRow(y, x, radius, rowPtr3, cols>>1, channels, frameId, positive);
    CircleRow(y, -x, radius, rowPtr4, cols>>1, channels, frameId, positive);
  }
}


